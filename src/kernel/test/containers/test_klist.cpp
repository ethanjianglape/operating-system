// This test code was generated by Claude (Anthropic).

#ifdef KERNEL_TESTS

#include <test/test.hpp>
#include <containers/klist.hpp>
#include <containers/kstring.hpp>
#include <log/log.hpp>

namespace test_klist {
    void test_default_constructor() {
        klist<int> l;
        test::assert_true(l.empty(), "default constructed klist is empty");
        test::assert_eq(l.size(), 0ul, "default constructed klist has size 0");
    }

    void test_count_constructor() {
        klist<int> l(5, 42);
        test::assert_eq(l.size(), 5ul, "count constructor creates correct size");
        test::assert_eq(l[0], 42, "count constructor fills with value");
        test::assert_eq(l[4], 42, "count constructor fills all elements");
    }

    void test_push_back() {
        klist<int> l;
        l.push_back(10);
        l.push_back(20);
        l.push_back(30);
        test::assert_eq(l.size(), 3ul, "push_back increases size");
        test::assert_eq(l[0], 10, "push_back stores first value");
        test::assert_eq(l[2], 30, "push_back stores last value");
    }

    void test_push_front() {
        klist<int> l;
        l.push_front(10);
        l.push_front(20);
        l.push_front(30);
        test::assert_eq(l.size(), 3ul, "push_front increases size");
        test::assert_eq(l[0], 30, "push_front inserts at front");
        test::assert_eq(l[2], 10, "push_front pushes existing to back");
    }

    void test_pop_back() {
        klist<int> l;
        l.push_back(1);
        l.push_back(2);
        l.push_back(3);
        l.pop_back();
        test::assert_eq(l.size(), 2ul, "pop_back decreases size");
        test::assert_eq(l.back(), 2, "pop_back removes last element");
    }

    void test_pop_front() {
        klist<int> l;
        l.push_back(1);
        l.push_back(2);
        l.push_back(3);
        l.pop_front();
        test::assert_eq(l.size(), 2ul, "pop_front decreases size");
        test::assert_eq(l.front(), 2, "pop_front removes first element");
    }

    void test_pop_back_empty() {
        klist<int> l;
        l.pop_back();  // Should not crash
        test::assert_true(l.empty(), "pop_back on empty list is safe");
    }

    void test_pop_front_empty() {
        klist<int> l;
        l.pop_front();  // Should not crash
        test::assert_true(l.empty(), "pop_front on empty list is safe");
    }

    void test_pop_back_to_empty() {
        klist<int> l;
        l.push_back(42);
        l.pop_back();
        test::assert_true(l.empty(), "pop_back single element empties list");
        test::assert_eq(l.size(), 0ul, "pop_back single element sets size to 0");
    }

    void test_pop_front_to_empty() {
        klist<int> l;
        l.push_front(42);
        l.pop_front();
        test::assert_true(l.empty(), "pop_front single element empties list");
        test::assert_eq(l.size(), 0ul, "pop_front single element sets size to 0");
    }

    void test_front_back() {
        klist<int> l;
        l.push_back(10);
        l.push_back(20);
        l.push_back(30);
        test::assert_eq(l.front(), 10, "front() returns first element");
        test::assert_eq(l.back(), 30, "back() returns last element");
    }

    void test_front_back_single() {
        klist<int> l;
        l.push_back(42);
        test::assert_eq(l.front(), 42, "front() on single element");
        test::assert_eq(l.back(), 42, "back() on single element (same as front)");
    }

    void test_operator_bracket() {
        klist<int> l;
        l.push_back(5);
        l.push_back(10);
        l.push_back(15);
        test::assert_eq(l[1], 10, "operator[] reads correctly");
        l[1] = 100;
        test::assert_eq(l[1], 100, "operator[] writes correctly");
    }

    void test_clear() {
        klist<int> l;
        l.push_back(1);
        l.push_back(2);
        l.push_back(3);
        l.push_back(4);
        l.push_back(5);
        l.clear();
        test::assert_true(l.empty(), "clear() empties list");
        test::assert_eq(l.size(), 0ul, "clear() sets size to 0");
    }

    void test_copy_constructor() {
        klist<int> l1;
        l1.push_back(1);
        l1.push_back(2);
        l1.push_back(3);
        klist<int> l2(l1);
        test::assert_eq(l2.size(), 3ul, "copy constructor copies size");
        test::assert_eq(l2[0], 1, "copy constructor copies elements");
        l2[0] = 100;
        test::assert_eq(l1[0], 1, "copy constructor creates independent copy");
    }

    void test_copy_constructor_empty() {
        klist<int> l1;
        klist<int> l2(l1);
        test::assert_true(l2.empty(), "copy constructor of empty list is empty");
    }

    void test_move_constructor() {
        klist<int> l1;
        l1.push_back(1);
        l1.push_back(2);
        l1.push_back(3);
        klist<int> l2(static_cast<klist<int>&&>(l1));
        test::assert_eq(l2.size(), 3ul, "move constructor transfers size");
        test::assert_eq(l2[0], 1, "move constructor transfers elements");
        test::assert_true(l1.empty(), "move constructor empties source");
    }

    void test_copy_assignment() {
        klist<int> l1;
        l1.push_back(1);
        l1.push_back(2);
        l1.push_back(3);
        klist<int> l2;
        l2 = l1;
        test::assert_eq(l2.size(), 3ul, "copy assignment copies size");
        test::assert_eq(l2[1], 2, "copy assignment copies elements");
        l2[0] = 100;
        test::assert_eq(l1[0], 1, "copy assignment creates independent copy");
    }

    void test_move_assignment() {
        klist<int> l1;
        l1.push_back(1);
        l1.push_back(2);
        l1.push_back(3);
        klist<int> l2;
        l2 = static_cast<klist<int>&&>(l1);
        test::assert_eq(l2.size(), 3ul, "move assignment transfers size");
        test::assert_eq(l2[0], 1, "move assignment transfers elements");
        test::assert_true(l1.empty(), "move assignment empties source");
    }

    void test_circular_structure() {
        // Verify the circular nature by checking front/back after various operations
        klist<int> l;
        l.push_back(1);
        l.push_back(2);
        l.push_back(3);

        // After push_back: 1 <-> 2 <-> 3 <-> (back to 1)
        test::assert_eq(l.front(), 1, "circular: front is 1");
        test::assert_eq(l.back(), 3, "circular: back is 3");

        l.push_front(0);
        // After push_front: 0 <-> 1 <-> 2 <-> 3 <-> (back to 0)
        test::assert_eq(l.front(), 0, "circular: front is 0 after push_front");
        test::assert_eq(l.back(), 3, "circular: back still 3 after push_front");

        l.pop_back();
        // After pop_back: 0 <-> 1 <-> 2 <-> (back to 0)
        test::assert_eq(l.back(), 2, "circular: back is 2 after pop_back");

        l.pop_front();
        // After pop_front: 1 <-> 2 <-> (back to 1)
        test::assert_eq(l.front(), 1, "circular: front is 1 after pop_front");
    }

    void test_many_elements() {
        klist<int> l;

        for (int i = 0; i < 100; i++) {
            l.push_back(i);
        }

        test::assert_eq(l.size(), 100ul, "many elements: size is 100");
        test::assert_eq(l.front(), 0, "many elements: front is 0");
        test::assert_eq(l.back(), 99, "many elements: back is 99");

        bool all_correct = true;
        for (int i = 0; i < 100 && all_correct; i++) {
            all_correct = (l[i] == i);
        }
        test::assert_true(all_correct, "many elements: all values correct via operator[]");
    }

    void test_alternating_push() {
        klist<int> l;

        // Alternate push_front and push_back
        l.push_back(0);   // [0]
        l.push_front(1);  // [1, 0]
        l.push_back(2);   // [1, 0, 2]
        l.push_front(3);  // [3, 1, 0, 2]
        l.push_back(4);   // [3, 1, 0, 2, 4]

        test::assert_eq(l.size(), 5ul, "alternating push: size is 5");
        test::assert_eq(l[0], 3, "alternating push: [0] is 3");
        test::assert_eq(l[1], 1, "alternating push: [1] is 1");
        test::assert_eq(l[2], 0, "alternating push: [2] is 0");
        test::assert_eq(l[3], 2, "alternating push: [3] is 2");
        test::assert_eq(l[4], 4, "alternating push: [4] is 4");
    }

    void test_alternating_pop() {
        klist<int> l;
        for (int i = 0; i < 6; i++) {
            l.push_back(i);
        }
        // [0, 1, 2, 3, 4, 5]

        l.pop_front();  // [1, 2, 3, 4, 5]
        l.pop_back();   // [1, 2, 3, 4]
        l.pop_front();  // [2, 3, 4]

        test::assert_eq(l.size(), 3ul, "alternating pop: size is 3");
        test::assert_eq(l.front(), 2, "alternating pop: front is 2");
        test::assert_eq(l.back(), 4, "alternating pop: back is 4");
    }

    void test_reuse_after_clear() {
        klist<int> l;
        l.push_back(1);
        l.push_back(2);
        l.clear();

        l.push_back(10);
        l.push_back(20);

        test::assert_eq(l.size(), 2ul, "reuse after clear: size is 2");
        test::assert_eq(l[0], 10, "reuse after clear: [0] is 10");
        test::assert_eq(l[1], 20, "reuse after clear: [1] is 20");
    }

    void test_kstring_elements() {
        klist<kstring> l;
        l.push_back(kstring("hello"));
        l.push_back(kstring("world"));
        l.push_back(kstring("test"));

        test::assert_eq(l.size(), 3ul, "kstring: size is 3");
        test::assert_true(l[0] == "hello", "kstring: [0] is hello");
        test::assert_true(l[2] == "test", "kstring: [2] is test");

        l.pop_back();
        test::assert_eq(l.size(), 2ul, "kstring: size after pop_back is 2");

        l.clear();
        test::assert_true(l.empty(), "kstring: clear empties list");
    }

    void test_kstring_copy() {
        klist<kstring> l1;
        l1.push_back(kstring("first"));
        l1.push_back(kstring("second"));

        klist<kstring> l2(l1);

        test::assert_eq(l2.size(), 2ul, "kstring copy: size is 2");
        test::assert_true(l2[0] == "first", "kstring copy: [0] is first");

        // Modify original, verify copy is independent
        l1[0] = kstring("modified");
        test::assert_true(l2[0] == "first", "kstring copy: independent of original");
    }

    // =========================================================================
    // Nested klist<klist<kstring>> tests
    // =========================================================================

    void test_nested_basic() {
        klist<klist<kstring>> outer;

        klist<kstring> inner1;
        inner1.push_back(kstring("a"));
        inner1.push_back(kstring("b"));

        klist<kstring> inner2;
        inner2.push_back(kstring("c"));
        inner2.push_back(kstring("d"));
        inner2.push_back(kstring("e"));

        outer.push_back(inner1);
        outer.push_back(inner2);

        test::assert_eq(outer.size(), 2ul, "nested basic: outer has 2 elements");
        test::assert_eq(outer[0].size(), 2ul, "nested basic: inner[0] has 2 elements");
        test::assert_eq(outer[1].size(), 3ul, "nested basic: inner[1] has 3 elements");
        test::assert_true(outer[0][0] == "a", "nested basic: [0][0] is a");
        test::assert_true(outer[1][2] == "e", "nested basic: [1][2] is e");
    }

    void test_nested_copy_outer() {
        klist<klist<kstring>> outer1;

        klist<kstring> inner;
        inner.push_back(kstring("hello"));
        inner.push_back(kstring("world"));
        outer1.push_back(inner);

        klist<klist<kstring>> outer2(outer1);

        test::assert_eq(outer2.size(), 1ul, "nested copy outer: size is 1");
        test::assert_eq(outer2[0].size(), 2ul, "nested copy outer: inner size is 2");
        test::assert_true(outer2[0][0] == "hello", "nested copy outer: [0][0] is hello");

        // Modify original, verify copy is independent
        outer1[0][0] = kstring("modified");
        test::assert_true(outer2[0][0] == "hello", "nested copy outer: independent copy");
    }

    void test_nested_move_outer() {
        klist<klist<kstring>> outer1;

        klist<kstring> inner;
        inner.push_back(kstring("test"));
        inner.push_back(kstring("string"));
        outer1.push_back(inner);

        klist<klist<kstring>> outer2(static_cast<klist<klist<kstring>>&&>(outer1));

        test::assert_true(outer1.empty(), "nested move outer: source emptied");
        test::assert_eq(outer2.size(), 1ul, "nested move outer: dest has 1 element");
        test::assert_true(outer2[0][0] == "test", "nested move outer: data transferred");
    }

    void test_nested_push_front_back_mix() {
        klist<klist<kstring>> outer;

        klist<kstring> first;
        first.push_back(kstring("first"));

        klist<kstring> second;
        second.push_back(kstring("second"));

        klist<kstring> third;
        third.push_back(kstring("third"));

        outer.push_back(first);   // [first]
        outer.push_front(second); // [second, first]
        outer.push_back(third);   // [second, first, third]

        test::assert_eq(outer.size(), 3ul, "nested push mix: size is 3");
        test::assert_true(outer[0][0] == "second", "nested push mix: [0] is second");
        test::assert_true(outer[1][0] == "first", "nested push mix: [1] is first");
        test::assert_true(outer[2][0] == "third", "nested push mix: [2] is third");
    }

    void test_nested_pop_destroys_inner() {
        klist<klist<kstring>> outer;

        klist<kstring> inner;
        inner.push_back(kstring("will be destroyed"));
        inner.push_back(kstring("also destroyed"));

        outer.push_back(inner);
        outer.push_back(inner);
        outer.push_back(inner);

        test::assert_eq(outer.size(), 3ul, "nested pop: initial size 3");

        outer.pop_back();
        test::assert_eq(outer.size(), 2ul, "nested pop: size after pop_back");

        outer.pop_front();
        test::assert_eq(outer.size(), 1ul, "nested pop: size after pop_front");

        // Remaining element should still be valid
        test::assert_eq(outer[0].size(), 2ul, "nested pop: remaining inner intact");
        test::assert_true(outer[0][0] == "will be destroyed", "nested pop: remaining data intact");
    }

    void test_nested_clear_all() {
        klist<klist<kstring>> outer;

        for (int i = 0; i < 5; i++) {
            klist<kstring> inner;
            inner.push_back(kstring("item"));
            inner.push_back(kstring("in"));
            inner.push_back(kstring("list"));
            outer.push_back(inner);
        }

        test::assert_eq(outer.size(), 5ul, "nested clear: initial size 5");

        outer.clear();

        test::assert_true(outer.empty(), "nested clear: outer is empty");
        test::assert_eq(outer.size(), 0ul, "nested clear: size is 0");
    }

    void test_nested_assignment() {
        klist<klist<kstring>> outer1;
        klist<kstring> inner;
        inner.push_back(kstring("assign"));
        inner.push_back(kstring("me"));
        outer1.push_back(inner);

        klist<klist<kstring>> outer2;
        klist<kstring> other;
        other.push_back(kstring("will be replaced"));
        outer2.push_back(other);
        outer2.push_back(other);

        outer2 = outer1;

        test::assert_eq(outer2.size(), 1ul, "nested assign: size after copy assign");
        test::assert_true(outer2[0][0] == "assign", "nested assign: data copied");

        // Verify independence
        outer1[0][0] = kstring("changed");
        test::assert_true(outer2[0][0] == "assign", "nested assign: independent after copy");
    }

    void test_nested_modify_inner_after_insert() {
        klist<klist<kstring>> outer;

        klist<kstring> inner;
        inner.push_back(kstring("original"));
        outer.push_back(inner);

        // Modify inner through outer
        outer[0].push_back(kstring("added"));
        outer[0].push_front(kstring("prepended"));

        test::assert_eq(outer[0].size(), 3ul, "nested modify: inner grew to 3");
        test::assert_true(outer[0][0] == "prepended", "nested modify: prepended at front");
        test::assert_true(outer[0][1] == "original", "nested modify: original in middle");
        test::assert_true(outer[0][2] == "added", "nested modify: added at back");
    }

    // =========================================================================
    // reverse() tests
    // =========================================================================

    void test_reverse_empty() {
        klist<int> l;
        l.reverse();  // Should not crash
        test::assert_true(l.empty(), "reverse empty: list still empty");
    }

    void test_reverse_single() {
        klist<int> l;
        l.push_back(42);
        l.reverse();
        test::assert_eq(l.size(), 1ul, "reverse single: size unchanged");
        test::assert_eq(l[0], 42, "reverse single: element unchanged");
        test::assert_eq(l.front(), 42, "reverse single: front unchanged");
        test::assert_eq(l.back(), 42, "reverse single: back unchanged");
    }

    void test_reverse_two() {
        klist<int> l;
        l.push_back(1);
        l.push_back(2);
        l.reverse();
        test::assert_eq(l.size(), 2ul, "reverse two: size unchanged");
        test::assert_eq(l[0], 2, "reverse two: [0] is 2");
        test::assert_eq(l[1], 1, "reverse two: [1] is 1");
        test::assert_eq(l.front(), 2, "reverse two: front is 2");
        test::assert_eq(l.back(), 1, "reverse two: back is 1");
    }

    void test_reverse_three() {
        klist<int> l;
        l.push_back(1);
        l.push_back(2);
        l.push_back(3);
        l.reverse();
        test::assert_eq(l.size(), 3ul, "reverse three: size unchanged");
        test::assert_eq(l[0], 3, "reverse three: [0] is 3");
        test::assert_eq(l[1], 2, "reverse three: [1] is 2");
        test::assert_eq(l[2], 1, "reverse three: [2] is 1");
        test::assert_eq(l.front(), 3, "reverse three: front is 3");
        test::assert_eq(l.back(), 1, "reverse three: back is 1");
    }

    void test_reverse_many() {
        klist<int> l;
        for (int i = 0; i < 10; i++) {
            l.push_back(i);
        }
        // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

        l.reverse();
        // [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]

        test::assert_eq(l.size(), 10ul, "reverse many: size unchanged");
        test::assert_eq(l.front(), 9, "reverse many: front is 9");
        test::assert_eq(l.back(), 0, "reverse many: back is 0");

        bool all_correct = true;
        for (int i = 0; i < 10 && all_correct; i++) {
            all_correct = (l[i] == 9 - i);
        }
        test::assert_true(all_correct, "reverse many: all elements in reverse order");
    }

    void test_reverse_twice() {
        klist<int> l;
        l.push_back(1);
        l.push_back(2);
        l.push_back(3);
        l.push_back(4);

        l.reverse();
        l.reverse();

        test::assert_eq(l[0], 1, "reverse twice: [0] back to 1");
        test::assert_eq(l[1], 2, "reverse twice: [1] back to 2");
        test::assert_eq(l[2], 3, "reverse twice: [2] back to 3");
        test::assert_eq(l[3], 4, "reverse twice: [3] back to 4");
    }

    void test_reverse_then_push() {
        klist<int> l;
        l.push_back(1);
        l.push_back(2);
        l.push_back(3);
        // [1, 2, 3]

        l.reverse();
        // [3, 2, 1]

        l.push_back(0);
        // [3, 2, 1, 0]

        l.push_front(4);
        // [4, 3, 2, 1, 0]

        test::assert_eq(l.size(), 5ul, "reverse then push: size is 5");
        test::assert_eq(l[0], 4, "reverse then push: [0] is 4");
        test::assert_eq(l[1], 3, "reverse then push: [1] is 3");
        test::assert_eq(l[4], 0, "reverse then push: [4] is 0");
        test::assert_eq(l.front(), 4, "reverse then push: front is 4");
        test::assert_eq(l.back(), 0, "reverse then push: back is 0");
    }

    void test_reverse_then_pop() {
        klist<int> l;
        l.push_back(1);
        l.push_back(2);
        l.push_back(3);
        l.push_back(4);
        // [1, 2, 3, 4]

        l.reverse();
        // [4, 3, 2, 1]

        l.pop_front();
        // [3, 2, 1]

        l.pop_back();
        // [3, 2]

        test::assert_eq(l.size(), 2ul, "reverse then pop: size is 2");
        test::assert_eq(l.front(), 3, "reverse then pop: front is 3");
        test::assert_eq(l.back(), 2, "reverse then pop: back is 2");
    }

    void test_reverse_kstring() {
        klist<kstring> l;
        l.push_back(kstring("first"));
        l.push_back(kstring("second"));
        l.push_back(kstring("third"));

        l.reverse();

        test::assert_eq(l.size(), 3ul, "reverse kstring: size unchanged");
        test::assert_true(l[0] == "third", "reverse kstring: [0] is third");
        test::assert_true(l[1] == "second", "reverse kstring: [1] is second");
        test::assert_true(l[2] == "first", "reverse kstring: [2] is first");
    }

    void test_reverse_circular_integrity() {
        // Verify circular structure is maintained after reverse
        klist<int> l;
        l.push_back(1);
        l.push_back(2);
        l.push_back(3);

        l.reverse();
        // [3, 2, 1]

        // Test circular by doing multiple operations that rely on it
        test::assert_eq(l.front(), 3, "reverse circular: front is 3");
        test::assert_eq(l.back(), 1, "reverse circular: back is 1");

        l.pop_front();
        test::assert_eq(l.front(), 2, "reverse circular: front after pop is 2");
        test::assert_eq(l.back(), 1, "reverse circular: back after pop is 1");

        l.push_front(5);
        test::assert_eq(l.front(), 5, "reverse circular: front after push_front is 5");
        test::assert_eq(l.back(), 1, "reverse circular: back after push_front is 1");

        l.push_back(0);
        test::assert_eq(l.front(), 5, "reverse circular: front after push_back is 5");
        test::assert_eq(l.back(), 0, "reverse circular: back after push_back is 0");
    }

    // =========================================================================
    // rotate_next() / rotate_prev() tests
    // =========================================================================

    void test_rotate_next_empty() {
        klist<int> l;
        l.rotate_next();  // Should not crash
        test::assert_true(l.empty(), "rotate_next empty: list still empty");
    }

    void test_rotate_next_single() {
        klist<int> l;
        l.push_back(42);
        l.rotate_next();
        test::assert_eq(l.front(), 42, "rotate_next single: front unchanged");
        test::assert_eq(l.back(), 42, "rotate_next single: back unchanged");
    }

    void test_rotate_next_basic() {
        klist<int> l;
        l.push_back(1);
        l.push_back(2);
        l.push_back(3);
        // [1, 2, 3]

        l.rotate_next();
        // [2, 3, 1]

        test::assert_eq(l.size(), 3ul, "rotate_next: size unchanged");
        test::assert_eq(l.front(), 2, "rotate_next: front is 2");
        test::assert_eq(l.back(), 1, "rotate_next: back is 1");
        test::assert_eq(l[0], 2, "rotate_next: [0] is 2");
        test::assert_eq(l[1], 3, "rotate_next: [1] is 3");
        test::assert_eq(l[2], 1, "rotate_next: [2] is 1");
    }

    void test_rotate_prev_basic() {
        klist<int> l;
        l.push_back(1);
        l.push_back(2);
        l.push_back(3);
        // [1, 2, 3]

        l.rotate_prev();
        // [3, 1, 2]

        test::assert_eq(l.size(), 3ul, "rotate_prev: size unchanged");
        test::assert_eq(l.front(), 3, "rotate_prev: front is 3");
        test::assert_eq(l.back(), 2, "rotate_prev: back is 2");
        test::assert_eq(l[0], 3, "rotate_prev: [0] is 3");
        test::assert_eq(l[1], 1, "rotate_prev: [1] is 1");
        test::assert_eq(l[2], 2, "rotate_prev: [2] is 2");
    }

    void test_rotate_full_cycle() {
        klist<int> l;
        l.push_back(1);
        l.push_back(2);
        l.push_back(3);

        // Rotate through entire list and back
        l.rotate_next();  // [2, 3, 1]
        l.rotate_next();  // [3, 1, 2]
        l.rotate_next();  // [1, 2, 3] - back to original

        test::assert_eq(l.front(), 1, "rotate full cycle: back to original front");
        test::assert_eq(l.back(), 3, "rotate full cycle: back to original back");

        // Same with rotate_prev
        l.rotate_prev();  // [3, 1, 2]
        l.rotate_prev();  // [2, 3, 1]
        l.rotate_prev();  // [1, 2, 3] - back to original

        test::assert_eq(l.front(), 1, "rotate_prev full cycle: back to original front");
        test::assert_eq(l.back(), 3, "rotate_prev full cycle: back to original back");
    }

    void test_rotate_round_robin() {
        // Simulate round-robin scheduler use case
        klist<int> ready_queue;
        ready_queue.push_back(100);  // PID 100
        ready_queue.push_back(200);  // PID 200
        ready_queue.push_back(300);  // PID 300

        // "Run" front process, then rotate to give next process a turn
        test::assert_eq(ready_queue.front(), 100, "round robin: first is 100");
        ready_queue.rotate_next();

        test::assert_eq(ready_queue.front(), 200, "round robin: second is 200");
        ready_queue.rotate_next();

        test::assert_eq(ready_queue.front(), 300, "round robin: third is 300");
        ready_queue.rotate_next();

        test::assert_eq(ready_queue.front(), 100, "round robin: back to 100");
    }

    // =========================================================================
    // remove() tests
    // =========================================================================

    void test_remove_empty() {
        klist<int> l;
        bool result = l.remove(42);
        test::assert_true(!result, "remove empty: returns false");
        test::assert_true(l.empty(), "remove empty: list still empty");
    }

    void test_remove_single() {
        klist<int> l;
        l.push_back(42);
        bool result = l.remove(42);
        test::assert_true(result, "remove single: returns true");
        test::assert_true(l.empty(), "remove single: list now empty");
        test::assert_eq(l.size(), 0ul, "remove single: size is 0");
    }

    void test_remove_front() {
        klist<int> l;
        l.push_back(1);
        l.push_back(2);
        l.push_back(3);
        // [1, 2, 3]

        bool result = l.remove(1);
        // [2, 3]

        test::assert_true(result, "remove front: returns true");
        test::assert_eq(l.size(), 2ul, "remove front: size is 2");
        test::assert_eq(l.front(), 2, "remove front: new front is 2");
        test::assert_eq(l.back(), 3, "remove front: back is 3");
        test::assert_eq(l[0], 2, "remove front: [0] is 2");
        test::assert_eq(l[1], 3, "remove front: [1] is 3");
    }

    void test_remove_back() {
        klist<int> l;
        l.push_back(1);
        l.push_back(2);
        l.push_back(3);
        // [1, 2, 3]

        bool result = l.remove(3);
        // [1, 2]

        test::assert_true(result, "remove back: returns true");
        test::assert_eq(l.size(), 2ul, "remove back: size is 2");
        test::assert_eq(l.front(), 1, "remove back: front is 1");
        test::assert_eq(l.back(), 2, "remove back: new back is 2");
    }

    void test_remove_middle() {
        klist<int> l;
        l.push_back(1);
        l.push_back(2);
        l.push_back(3);
        // [1, 2, 3]

        bool result = l.remove(2);
        // [1, 3]

        test::assert_true(result, "remove middle: returns true");
        test::assert_eq(l.size(), 2ul, "remove middle: size is 2");
        test::assert_eq(l.front(), 1, "remove middle: front is 1");
        test::assert_eq(l.back(), 3, "remove middle: back is 3");
        test::assert_eq(l[0], 1, "remove middle: [0] is 1");
        test::assert_eq(l[1], 3, "remove middle: [1] is 3");
    }

    void test_remove_not_found() {
        klist<int> l;
        l.push_back(1);
        l.push_back(2);
        l.push_back(3);

        bool result = l.remove(99);

        test::assert_true(!result, "remove not found: returns false");
        test::assert_eq(l.size(), 3ul, "remove not found: size unchanged");
    }

    void test_remove_duplicates() {
        klist<int> l;
        l.push_back(1);
        l.push_back(2);
        l.push_back(1);
        l.push_back(3);
        l.push_back(1);
        // [1, 2, 1, 3, 1]

        bool result = l.remove(1);
        // Should remove first occurrence: [2, 1, 3, 1]

        test::assert_true(result, "remove duplicates: returns true");
        test::assert_eq(l.size(), 4ul, "remove duplicates: size is 4");
        test::assert_eq(l.front(), 2, "remove duplicates: front is 2");
        test::assert_eq(l[1], 1, "remove duplicates: second 1 still present");
    }

    void test_remove_then_operate() {
        // Verify list integrity after remove by doing various operations
        klist<int> l;
        l.push_back(1);
        l.push_back(2);
        l.push_back(3);
        l.push_back(4);

        l.remove(2);
        // [1, 3, 4]

        l.push_back(5);
        // [1, 3, 4, 5]

        l.push_front(0);
        // [0, 1, 3, 4, 5]

        test::assert_eq(l.size(), 5ul, "remove then operate: size is 5");
        test::assert_eq(l.front(), 0, "remove then operate: front is 0");
        test::assert_eq(l.back(), 5, "remove then operate: back is 5");

        l.rotate_next();
        test::assert_eq(l.front(), 1, "remove then operate: rotate works");
        
        l.pop_back();
        // [1, 3, 4, 5] - removed the 0 from the back
        test::assert_eq(l.back(), 5, "remove then operate: pop_back works");
    }

    void run() {
        log::info("Running klist tests...");

        test_default_constructor();
        test_count_constructor();
        test_push_back();
        test_push_front();
        test_pop_back();
        test_pop_front();
        test_pop_back_empty();
        test_pop_front_empty();
        test_pop_back_to_empty();
        test_pop_front_to_empty();
        test_front_back();
        test_front_back_single();
        test_operator_bracket();
        test_clear();
        test_copy_constructor();
        test_copy_constructor_empty();
        test_move_constructor();
        test_copy_assignment();
        test_move_assignment();
        test_circular_structure();
        test_many_elements();
        test_alternating_push();
        test_alternating_pop();
        test_reuse_after_clear();
        test_kstring_elements();
        test_kstring_copy();

        // Nested klist<klist<kstring>> tests
        test_nested_basic();
        test_nested_copy_outer();
        test_nested_move_outer();
        test_nested_push_front_back_mix();
        test_nested_pop_destroys_inner();
        test_nested_clear_all();
        test_nested_assignment();
        test_nested_modify_inner_after_insert();

        // reverse() tests
        test_reverse_empty();
        test_reverse_single();
        test_reverse_two();
        test_reverse_three();
        test_reverse_many();
        test_reverse_twice();
        test_reverse_then_push();
        test_reverse_then_pop();
        test_reverse_kstring();
        test_reverse_circular_integrity();

        // rotate_next()/rotate_prev() tests
        test_rotate_next_empty();
        test_rotate_next_single();
        test_rotate_next_basic();
        test_rotate_prev_basic();
        test_rotate_full_cycle();
        test_rotate_round_robin();

        // remove() tests
        test_remove_empty();
        test_remove_single();
        test_remove_front();
        test_remove_back();
        test_remove_middle();
        test_remove_not_found();
        test_remove_duplicates();
        test_remove_then_operate();
    }
}

#endif // KERNEL_TESTS
