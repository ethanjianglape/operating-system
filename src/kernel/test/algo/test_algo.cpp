// This test code was generated by Claude (Anthropic).

#ifdef KERNEL_TESTS

#include <test/test.hpp>
#include <algo/algo.hpp>
#include <containers/klist.hpp>
#include <containers/kstring.hpp>
#include <log/log.hpp>

namespace test_algo {
    // =========================================================================
    // join() tests for klist<T>
    // =========================================================================

    void test_join_empty() {
        klist<int> l;
        kstring result = algo::join(l, ',');
        test::assert_true(result.empty(), "join empty: result is empty string");
    }

    void test_join_single() {
        klist<int> l;
        l.push_back(42);
        kstring result = algo::join(l, ',');
        test::assert_true(result == "42", "join single: result is '42'");
    }

    void test_join_multiple_ints() {
        klist<int> l;
        l.push_back(1);
        l.push_back(2);
        l.push_back(3);
        kstring result = algo::join(l, ',');
        test::assert_true(result == "1,2,3", "join multiple ints: result is '1,2,3'");
    }

    void test_join_space_delim() {
        klist<int> l;
        l.push_back(10);
        l.push_back(20);
        l.push_back(30);
        kstring result = algo::join(l, ' ');
        test::assert_true(result == "10 20 30", "join space delim: result is '10 20 30'");
    }

    void test_join_kstring_list() {
        klist<kstring> l;
        l.push_back(kstring("hello"));
        l.push_back(kstring("world"));
        l.push_back(kstring("test"));
        kstring result = algo::join(l, '-');
        test::assert_true(result == "hello-world-test", "join kstring list: result is 'hello-world-test'");
    }

    void test_join_after_rotate() {
        klist<int> l;
        l.push_back(1);
        l.push_back(2);
        l.push_back(3);
        // [1, 2, 3]

        l.rotate_next();
        // [2, 3, 1]

        kstring result = algo::join(l, ',');
        test::assert_true(result == "2,3,1", "join after rotate: result is '2,3,1'");
    }

    void test_join_after_reverse() {
        klist<int> l;
        l.push_back(1);
        l.push_back(2);
        l.push_back(3);
        // [1, 2, 3]

        l.reverse();
        // [3, 2, 1]

        kstring result = algo::join(l, ',');
        test::assert_true(result == "3,2,1", "join after reverse: result is '3,2,1'");
    }

    // =========================================================================
    // split() tests
    // =========================================================================

    void test_split_empty() {
        kstring s = "";
        auto parts = algo::split(s, ',');
        test::assert_eq(parts.size(), 0ul, "split empty: no parts");
    }

    void test_split_no_delim() {
        kstring s = "hello";
        auto parts = algo::split(s, ',');
        test::assert_eq(parts.size(), 1ul, "split no delim: one part");
        test::assert_true(parts[0] == "hello", "split no delim: part is 'hello'");
    }

    void test_split_basic() {
        kstring s = "a,b,c";
        auto parts = algo::split(s, ',');
        test::assert_eq(parts.size(), 3ul, "split basic: three parts");
        test::assert_true(parts[0] == "a", "split basic: [0] is 'a'");
        test::assert_true(parts[1] == "b", "split basic: [1] is 'b'");
        test::assert_true(parts[2] == "c", "split basic: [2] is 'c'");
    }

    void test_split_removes_empty() {
        kstring s = "a::b:c:::d";
        auto parts = algo::split(s, ':');
        test::assert_eq(parts.size(), 4ul, "split removes empty: four parts");
        test::assert_true(parts[0] == "a", "split removes empty: [0] is 'a'");
        test::assert_true(parts[1] == "b", "split removes empty: [1] is 'b'");
        test::assert_true(parts[2] == "c", "split removes empty: [2] is 'c'");
        test::assert_true(parts[3] == "d", "split removes empty: [3] is 'd'");
    }

    void test_split_leading_trailing() {
        kstring s = ",a,b,";
        auto parts = algo::split(s, ',');
        test::assert_eq(parts.size(), 2ul, "split leading/trailing: two parts");
        test::assert_true(parts[0] == "a", "split leading/trailing: [0] is 'a'");
        test::assert_true(parts[1] == "b", "split leading/trailing: [1] is 'b'");
    }

    void test_split_spaces() {
        kstring s = "hello world test";
        auto parts = algo::split(s, ' ');
        test::assert_eq(parts.size(), 3ul, "split spaces: three parts");
        test::assert_true(parts[0] == "hello", "split spaces: [0] is 'hello'");
        test::assert_true(parts[1] == "world", "split spaces: [1] is 'world'");
        test::assert_true(parts[2] == "test", "split spaces: [2] is 'test'");
    }

    // =========================================================================
    // tokenize() tests
    // =========================================================================

    void test_tokenize_empty() {
        const kstring s = "";
        auto parts = algo::tokenize(s.begin(), s.end(), ',');
        test::assert_eq(parts.size(), 0ul, "tokenize empty: no parts");
    }

    void test_tokenize_no_delim() {
        const kstring s = "hello";
        auto parts = algo::tokenize(s.begin(), s.end(), ',');
        test::assert_eq(parts.size(), 1ul, "tokenize no delim: one part");
        test::assert_true(parts[0] == "hello", "tokenize no delim: part is 'hello'");
    }

    void test_tokenize_basic() {
        const kstring s = "a,b,c";
        auto parts = algo::tokenize(s.begin(), s.end(), ',');
        test::assert_eq(parts.size(), 3ul, "tokenize basic: three parts");
        test::assert_true(parts[0] == "a", "tokenize basic: [0] is 'a'");
        test::assert_true(parts[1] == "b", "tokenize basic: [1] is 'b'");
        test::assert_true(parts[2] == "c", "tokenize basic: [2] is 'c'");
    }

    void test_tokenize_keeps_empty() {
        const kstring s = "a::b:c:::d";
        auto parts = algo::tokenize(s.begin(), s.end(), ':');
        test::assert_eq(parts.size(), 7ul, "tokenize keeps empty: seven parts");
        test::assert_true(parts[0] == "a", "tokenize keeps empty: [0] is 'a'");
        test::assert_true(parts[1] == "", "tokenize keeps empty: [1] is empty");
        test::assert_true(parts[2] == "b", "tokenize keeps empty: [2] is 'b'");
        test::assert_true(parts[3] == "c", "tokenize keeps empty: [3] is 'c'");
        test::assert_true(parts[4] == "", "tokenize keeps empty: [4] is empty");
        test::assert_true(parts[5] == "", "tokenize keeps empty: [5] is empty");
        test::assert_true(parts[6] == "d", "tokenize keeps empty: [6] is 'd'");
    }

    void test_tokenize_leading_trailing() {
        const kstring s = ",a,b,";
        auto parts = algo::tokenize(s.begin(), s.end(), ',');
        test::assert_eq(parts.size(), 4ul, "tokenize leading/trailing: four parts");
        test::assert_true(parts[0] == "", "tokenize leading/trailing: [0] is empty");
        test::assert_true(parts[1] == "a", "tokenize leading/trailing: [1] is 'a'");
        test::assert_true(parts[2] == "b", "tokenize leading/trailing: [2] is 'b'");
        test::assert_true(parts[3] == "", "tokenize leading/trailing: [3] is empty");
    }

    void run() {
        log::info("Running algo tests...");

        test_join_empty();
        test_join_single();
        test_join_multiple_ints();
        test_join_space_delim();
        test_join_kstring_list();
        test_join_after_rotate();
        test_join_after_reverse();

        test_split_empty();
        test_split_no_delim();
        test_split_basic();
        test_split_removes_empty();
        test_split_leading_trailing();
        test_split_spaces();

        test_tokenize_empty();
        test_tokenize_no_delim();
        test_tokenize_basic();
        test_tokenize_keeps_empty();
        test_tokenize_leading_trailing();
    }
}

#endif // KERNEL_TESTS
